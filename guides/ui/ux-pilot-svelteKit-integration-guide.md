# Systematic Approach for UX Pilot to SvelteKit Integration

This guide documents how we convert UX Pilot screen exports into maintainable SvelteKit pages while building a reusable UI kit.

## 1. Shared Foundation

- **Global shell**: Move all head-level assets (Google Fonts, icon scripts, meta tags) into `src/app.html`. Keep UX Pilot HTML limited to page content.
- **Design tokens**: Define visual primitives in JSON under `tokens/` (e.g. `color.json`, `spacing.json`, `typography.json`, `radius.json`, `elevation.json`).
- **Generated artifacts**: Run Style Dictionary to emit `src/lib/styles/tokens.css` (CSS variables) and `src/lib/design/tokens.ts` (typed map).

```bash
npm run build:tokens         # manual run
# Executed automatically via npm postinstall and prebuild hooks
```

## 2. Style Dictionary Configuration

- `style-dictionary.config.cjs` defines two platforms: CSS variables and TypeScript exports.
- `scripts/build-tokens.cjs` registers a custom TypeScript formatter and builds all platforms using the v5 Style Dictionary API.
- Tokens are regenerated by default on dependency install and before production builds to keep CSS and TypeScript in sync.

## 3. Svelte App Integration

- Import generated CSS at the top of `src/app.css`, followed by `@import 'tailwindcss';`.
- Use the Tailwind v4 `@theme` block to map Style Dictionary tokens to alias variables (colors, spacing, radii, typography, elevations). This keeps utilities in sync during both dev and build.
- Register plugins through `@plugin` directives in `app.css` (e.g. `@plugin '@tailwindcss/forms';`).
- Keep `tailwind.config.js` minimal—only provide the `content` globs so Tailwind can tree-shake the generated utilities. All theming now lives in CSS.

```css
/* src/app.css */
@import './lib/styles/tokens.css';
@import 'tailwindcss';

@theme {
	--color-brand-primary: var(--color-brand-primary);
	/* ...other token mappings... */
}

@plugin '@tailwindcss/forms';
@plugin '@tailwindcss/typography';
```

```js
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
	content: ['./src/**/*.{html,js,svelte,ts}']
};
```

> **Tip**: Editor warnings about `@tailwind` at-rules stem from PostCSS not resolving Tailwind in isolation. They disappear during actual builds.

### Tailwind v4 migration notes

- Adopt Tailwind's new `@import 'tailwindcss'` + `@theme` syntax. Map each Style Dictionary token to the Tailwind alias layer inside `@theme` so utilities (e.g. `bg-brand-primary`) resolve in both dev and build outputs.
- Keep the Tailwind entry file minimal—remove bespoke resets and base typography rules so Tailwind Preflight owns the cascade. Legacy resets in the `web` app were overriding spacing/line-height until they were deleted.
- Tailwind v4 caches resolved design tokens; restart the dev server after changing `@theme` mappings or imported token files to guarantee the new values take effect.
- Plugins now load through the `@plugin` directive inside CSS. Declare `@plugin '@tailwindcss/forms'` and `@plugin '@tailwindcss/typography'` directly below the `@theme` block.
- When debugging mismatched output, create a fresh SvelteKit sandbox (e.g. `tmp-sveltekit/`) that shares the exact `app.css` and primitives. Once the reference render matches UX Pilot, reapply changes to the production app to isolate environment-specific overrides.

## 4. UI Kit Architecture

- Organise `src/lib/ui/` into three tiers that we build **in order** for every imported UX Pilot page. Route files (`src/routes/**/+page.svelte`) compose directly from these tiers; we no longer mirror routes under `src/lib/components/pages`.
  1. `layout/`: Responsive scaffolding such as Container, SectionHeader, Footer, Stack, Grid. These components establish shared gaps, breakpoints, and alignment.
  2. `patterns/`: Page-level compositions that appear more than once (Hero band, Filter panel, Listings rail, Review list, Contact card). Patterns wrap layout pieces and primitives so subsequent screens can reuse them.
  3. `primitives/`: Leaf widgets (Button, Card, Badge, Input, Toggle, Icon wrapper) that expose tokens and interactive states.
- Always start a migration by extracting the layout tier, follow with patterns, and only then refine or extend primitives. This keeps responsive behaviour intact before we optimise atoms.
- Before creating a new component, check whether the needed layout/pattern/primitive already exists from earlier migrations. Only the first screen should require fresh builds; later screens should compose or extend what’s already present.
- Each component consumes tokens via Tailwind utilities or CSS variables and uses Svelte runes for interactions.
- Maintain barrel exports (e.g. `src/lib/ui/index.ts`, `src/lib/ui/layout/index.ts`) so pages can import by tier.
- **Status checkpoint**: primitives are in place; layout and pattern inventories still need to be defined as we port each screen.

## 5. Migration Workflow for UX Pilot Screens

1. **Strip boilerplate**: Remove `<!DOCTYPE html>`, `<html>`, `<head>`, inline scripts, and CDN styles from the generated markup.
2. **Extract layout tier**: Identify the responsive structure, prefer existing layout components under `src/lib/ui/layout/`, and only create new ones when no suitable option exists. Apply layout components to the page while keeping route-specific wrappers local.
3. **Promote patterns**: Group repeated feature blocks into pattern components (`src/lib/ui/patterns/`) reusing existing layouts and primitives. Create or extend patterns only when the screen introduces something new.
4. **Refine primitives**: Reuse existing primitives wherever possible; extend or add new ones only when a pattern exposes a missing capability.
5. **Rebuild interactions**: Convert DOM events and state handling to Svelte 5 runes (`let state = $state(...)`, `onclick`, `$effect`).
6. **Apply tokens & test**: Ensure Tailwind utilities or CSS variables replace hard-coded values, then run automated checks (Vitest, Playwright) to confirm behaviour matches the UX reference.

Example suggested order: Home page → Listings index → Listing detail, since each unlocks reusable layout and pattern components for the next screen.

## 6. Legacy Component Cleanup

- Audit `src/lib/components/shared` and map each module to the new UI kit.
- Deprecate or refactor components gradually to avoid breaking existing routes.
- Track progress in project docs and remove unused code once migrations complete.

## 7. Ongoing Maintenance

- **Adding tokens**: Update the appropriate JSON file, run `npm run build:tokens`, commit both the source and generated outputs.
- **Tooling updates**: If Style Dictionary or Tailwind change, update this guide and adjust scripts accordingly.
- **Documentation**: Expand this guide with new patterns, component APIs, and troubleshooting notes as the UI kit matures.

## 8. Svelte 5 Component Authoring Checklist

- **Props**: Type component inputs with `$props<>()` instead of `export let`. Provide sensible defaults via `$derived` expressions so primitives remain tree-shakeable.@/home/nickt/projects/smw/web/src/lib/ui/primitives/Button.svelte#1-47
- **Derived values**: Replace `$:` statements with `$derived` runes to compute class maps, slot wrappers, and state derived from props.@/home/nickt/projects/smw/web/src/lib/ui/primitives/Card.svelte#17-60
- **Slots**: Model slots as optional `Snippet` props in `$props()` and render with `{@render slot()}` guards. Fall back to a typed `$slots()` assignment (`let slots: Slots; slots = $slots();`) only when you need introspection beyond snippet usage.@/home/nickt/projects/smw/web/src/lib/ui/primitives/Button.svelte#20-84
- **Styling**: Keep class lists token-driven—read CSS variables or Tailwind utilities generated from Style Dictionary within `$derived` helpers so UI pieces stay in sync with the design system.@/home/nickt/projects/smw/web/src/lib/ui/primitives/Badge.svelte#37-99
- **Events & effects**: Use native DOM attributes (`onclick`, `onchange`) and `$effect` hooks when behavior or side-effects are required; avoid legacy `on:` directives and lifecycle imports.
- **Testing**: After adding or updating primitives, run `npm run check` for Svelte diagnostics and extend Playwright/Vitest coverage so new patterns remain stable.

By following this workflow, we keep UX Pilot imports consistent, token-driven, and easy to evolve alongside the SvelteKit codebase.
